# -*- coding: utf-8 -*-
"""Hw3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bxLronjDq3JR9s2ggdeWuJRJMTx5hUx7
"""

# -*- coding: utf-8 -*-
"""
Created on Mon Feb 10 23:53:12 2020

@author: Risi
"""
import torchvision
import torchvision.transforms as tvt
import torch
import torch.nn as nn
import torch.nn.functional as F
import pdb
import numpy as np
#import seaborn as sn
#from matplotlib import pyplot as plt


f=open("output.txt","w")

torch.manual_seed(0)
np.random.seed(0)
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False

transform = tvt.Compose([tvt.ToTensor(), tvt.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])
## Define where the training and the test datasets are located:
train_data_loc = torchvision.datasets.CIFAR10(root=".", train=True,download=True, transform=transform)
test_data_loc = torchvision.datasets.CIFAR10(root=".", train=False,download=True,transform=transform)


## Now create the data loaders:
train_data_loader = torch.utils.data.DataLoader(train_data_loc, batch_size=4,shuffle=True)
testloader = torch.utils.data.DataLoader(test_data_loc, batch_size=4, shuffle=False)

dtype = torch.float
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

class TemplateNet_task1(nn.Module):
    def __init__(self):
        super(TemplateNet_task1, self).__init__()
        self.conv1 = nn.Conv2d(3, 128, 3) ## (A)
        #self.conv2 = nn.Conv2d(128, 128, 3) ## (B)
        self.pool = nn.MaxPool2d(2, 2)        
        self.fc1 = nn.Linear(28800, 1000) ## (C)
        self.fc2 = nn.Linear(1000, 10)
        
    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        #x = self.pool(F.relu(self.conv2(x))) ## (D)
        x = x.view(-1, 28800) ## (E)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

class TemplateNet_task2(nn.Module):
    def __init__(self):
        super(TemplateNet_task2, self).__init__()
        self.conv1 = nn.Conv2d(3, 128, 3) ## (A)
        self.conv2 = nn.Conv2d(128, 128, 3) ## (B)
        self.pool = nn.MaxPool2d(2, 2)        
        self.fc1 = nn.Linear(4608, 1000) ## (C)
        self.fc2 = nn.Linear(1000, 10)
        
    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x))) ## (D)
        x = x.view(-1, 4608) ## (E)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x


class TemplateNet(nn.Module):
    def __init__(self):
        super(TemplateNet, self).__init__()
        self.conv1 = nn.Conv2d(3, 128, 3,padding=1) ## (A)
        self.conv2 = nn.Conv2d(128, 128, 3) ## (B)
        self.pool = nn.MaxPool2d(2, 2)        
        self.fc1 = nn.Linear(6272, 1000) ## (C)
        self.fc2 = nn.Linear(1000, 10)
        
    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x))) ## (D)
        x = x.view(-1, 6272) ## (E)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x


epochs=1
def run_code_for_training(net):
    net = net.to(device)
    criterion = torch.nn.CrossEntropyLoss()
    optimizer = torch.optim.SGD(net.parameters(), lr=1e-3, momentum=0.9)
    for epoch in range(epochs):
        running_loss = 0.0
        for i, data in enumerate(train_data_loader):
            inputs, labels = data
            inputs = inputs.to(device)
            labels = labels.to(device)
            optimizer.zero_grad()
            outputs = net(inputs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            running_loss += loss.item()
            if i % 2000 == 1999:
                if(i+1 == 12000):
                  f.write("[epoch:%d, batch:%5d] loss: %.3f\n" %(epoch + 1, i + 1, running_loss / float(2000)))
                print("\n[epoch:%d, batch:%5d] loss: %.3f" %
                      (epoch + 1, i + 1, running_loss / float(2000)))
                running_loss = 0.0


def run_code_for_testing(net):
    net = net.to(device)
    CM = torch.zeros((10,10))
    for i, data in enumerate(testloader):
        inputs, labels = data
        inputs = inputs.to(device)
        labels = labels.to(device)
        outputs = net(inputs)
        for j in range(len(labels)):
          CM[labels[j]][torch.argmax(outputs[j])]+=1
    torch.set_printoptions(sci_mode=False)
    return CM



net=TemplateNet_task1()
run_code_for_training(net)

net=TemplateNet_task2()
run_code_for_training(net)
                
net=TemplateNet()
run_code_for_training(net)

CM=run_code_for_testing(net)
f.write(str(CM))
f.close()

#from matplotlib import pyplot as plt
#fig,ax= plt.subplots(figsize=(20,10))
#ax.set_xlabel('Predicted labels');ax.set_ylabel('True labels')
#ax.set_title('Confusion Matrix')
#labels_list=['airplane', 'autombile','bird','cat','deer','dog','frog','horse','sheep','truck']
#sn.heatmap(CM, annot=True,ax = ax,fmt='g',cmap='Reds',xticklabels=labels_list,yticklabels=labels_list)

#[torch.sum(CM[i]) for i in range(10)]

